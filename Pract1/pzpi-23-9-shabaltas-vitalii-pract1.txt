Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук

Кафедра програмної інженерії



ЗВІТ
до практичного завдання № 1 
з дисципліни «Правила оформлення програмного коду в PHP для веброзробки згідно стандарту PSR-12»






 
Виконали:
ст. гр. ПЗПІ-23-9
Шабалтас Віталій

 
                 Перевірив:
                 ст. викладач катедри ПІ
                 Сокорчук Ігор Петрович 





Харків 2025


Зміст

Зміст	2
1 ІСТОРІЯ ЗМІН	3
2 ЗАВДАННЯ	4
2.1 Мета	4
2.2 Хід роботи	4
3 ОПИС ВИКОНАНОЇ РОБОТИ	5
3.1 Вступ	5
3.2 Основні правила PSR-12	5
3.2.1 Рекомендація 1. Початок файлу: <?php та declare(strict_types=1);	5
3.2.2 Рекомендація 2. namespace і use — порядок і розташування	6
3.2.3 Рекомендація 3. Відступи — чотири пробіли, не таби	7
3.2.4 Рекомендація 4. Відступи — чотири пробіли, не таби	7
3.2.5 Рекомендація 5. Пробіли навколо операторів і після ком	8
3.2.6 Рекомендація 6. Коментарі та документація (PHPDoc)	8
3.2.7 Рекомендація 7. Кодування файлу та порожній рядок у кінці	9
3.2.8 Рекомендація 8. Довжина рядка і розбиття виразів (макс ~120 символів)	10
3.2.9 Рекомендація 9. Іменування: класи, методи, змінні, константи	10
3.2.10 Рекомендація 10. Сигнатури функцій/методів: типи, порядок, форматування	11
3.2.11 Рекомендація 11. Видимість та порядок членів класу	12
3.2.12 Рекомендація 12. Обробка помилок: винятки замість тихого повернення false/null	13
3.4 Інструменти та автоматизація для підтримки якості коду	14
3.4.1 PHP_CodeSniffer (phpcs)	14
3.4.2 PHP-CS-Fixer	14
3.4.3 Статичний аналіз коду	14
3.4.4 Автоматизація перевірок стилю	15
4 ВИСНОВКИ	16
5 ВИКОРИСТАНІ ДЖЕРЕЛА	17
ДОДАТОК А	18
ДОДАТОК Б	19
ДОДАТОК В	28

 
1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	27.10.2025	0.1	Створено розділ «Завдання»
2	28.10.2025	0.1	Створено розділ 
«Опис виконання роботи»
3	29.10.2025	0.1	Створено розділ «Висновок»
4	30.10.2025	0.1	Створено розділ «Висновок» 
та «Використані джерела»
5	30.10.2025	0.1	Створено додатки «А», «Б» і «В»


 
2 ЗАВДАННЯ
2.1 Мета
Дослідити та представити правила оформлення коду PHP згідно стандарту PSR-12, показати приклади застосування правил, обґрунтувати важливість цих правил та надати інструменти/конфігурації для автоматичної перевірки і виправлення.
 2.2 Хід роботи
1)	Ознайомитися з офіційним стандартом PSR-12;
2)	Проаналізовати основні вимоги до оформлення PHP-коду відповідно до стандарту;
3)	Навести приклади правильного та неправильного оформлення коду;
4)	Описати основні інструменти для перевірки дотримання стандарту PSR-12;
5)	Розглянути можливість автоматичної перевірки стилю коду у процесах CI/CD з використанням GitHub Actions;
6)	Сформульовати висновки. 
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ
Стандарт PSR-12 встановлює єдиний стиль написання PHP-коду, включно з відступами, форматуванням дужок, іменуванням змінних і методів, використанням пробілів та документацією через PHPDoc. Дотримання цього стандарту забезпечує однорідність коду в команді, підвищує його читабельність і зрозумілість, полегшує автоматичну перевірку та зменшує ризик стилістичних помилок. Це дозволяє розробникам зосередитися на логіці програми та спрощує підтримку і масштабування проєкту.
3.2 Основні правила PSR-12
Нижче наведено ключові правила з поясненнями, прикладами «погано/добре» та коротким обґрунтуванням.
3.2.1 Рекомендація 1. Початок файлу: <?php та declare(strict_types=1);
Опис: Файл має починатися з <?php. Закриваючий тег ?> в PHP-файлах, що містять лише PHP, заборонений. Якщо використовуєте строгу типізацію, розміщуйте declare(strict_types=1); одразу після відкриваючого тегу.
Приклад:
1 // Поганий приклад
2 <?php
3 // ……
4 ?>
5 // Гарний приклад
6 <?php
7 declare(strict_types=1);
8
9 namespace App\Services;
10
11 class Example
12 {
13    // ...
14 }
Пояснення: Закриваючий ?> може ненавмисно додати один або більше символів (новий рядок/пробіли) після нього, що призведе до «headers already sent» помилок при відправці HTTP-заголовків або при роботі з сесіями. Видалення ?> у файлах, що містять тільки PHP — найпростіший спосіб уникнути цих проблем.
declare(strict_types=1); змушує мову виконувати сувору перевірку типів аргументів та повертаних значень при виклику функцій/методів. Це виявляє помилки типізації на ранніх етапах і робить поведінку функцій передбачуваною. Розміщення директиви одразу вгорі забезпечує її застосування для усього файлу. Однорідність (всі файли починаються однаково) полегшує аналіз і автоматичні перевірки.
3.2.2 Рекомендація 2. namespace і use — порядок і розташування
Опис: Якщо файл містить namespace, він має бути визначений одразу після declare. Всі use-оператори йдуть після namespace. Імпорти — кожен в окремому рядку, відсортовані логічно/алфавітно.
Приклад:
1 // Поганий приклад
2 <?php
3 use Psr\Log\LoggerInterface;
4 namespace App\Controllers;
5
6 class C { }
7 // Гарний приклад
8 <?php
9 declare(strict_types=1);
10 
11 namespace App\Controllers;
12
13 use App\Models\User;
14 use Psr\Log\LoggerInterface;
15 
16 class UserController
17 {
18    // ...
19 }
Пояснення: Позиція namespace обумовлює видимість імен у файлі; розміщення після declare — єдиний упорядкований підхід. Поміщення use до namespace є синтаксично допустимим в деяких випадках, але є неконсистентним і плутає читача — PSR наполягає на стандартному порядку. Окремі рядки для use полегшують додавання/видалення імпортів та інструментальну обробку (рефакторинг, автодоповнення IDE). Сортування імпортів — зменшує конфлікти в diff при роботі багатьох розробників і полегшує пошук залежностей.
3.2.3 Рекомендація 3. Відступи — чотири пробіли, не таби
Опис: Використовуйте 4 пробіли для одного рівня відступу. Не використовувати символ табуляції (TAB).
Приклад:
1	// Поганий приклад (із табами або змішаними відступами):
2	if ($a) {
3	\tdoSomething();
4	}
5	// Гарний приклад
6	if ($a) {
7	doSomething();
8	}
Пояснення: Табуляція виглядає по-різному в різних редакторах/налаштуваннях (кожен може бачити різну ширину таба). Пробіли гарантують однаковий візуальний вигляд у всіх середовищах. 4 пробіли — компроміс між глибиною видимості структури і економією ширини рядка; це усталений стандарт у багатьох мовах (Python, PSR). Змішані відступи (таби + пробіли) часто призводять до нечіткої структури і складних до виявлення багів — статичні аналізатори їх ловлять.
3.2.4 Рекомендація 4. Відступи — чотири пробіли, не таби
Опис: Відкриваюча фігурна дужка класу, функції або методу має бути на новому рядку. Тіло блоку починається з нового рядка і відступа.
Приклад:
1	// Поганий приклад 
2	class A { public function foo(){return true;} }
3	// Гарний приклад 
4	class A
5	{
6	    public function foo()
7	    {
8	        return true;
9	    }
10	}
Пояснення: Розміщення дужок на новому рядку підвищує читабельність і скорочує кількість синтаксичних конструкцій в одному рядку. Коли клас/функція розростається, структура залишається чіткою. Це полегшує огляд diff-ів у VCS: додавання методу змінює невелику кількість рядків. Консистентність формату важлива для інструментів форматування — автозаміни та рефакторингу.
3.2.5 Рекомендація 5. Пробіли навколо операторів і після ком
Опис: Ставте пробіли навколо операторів присвоєння і арифметики (=, +, -, ==, ===, && тощо) і обов’язково після ком у списках.
Приклад:
1	// Поганий приклад 
2	$a=1+$b;
3	list($a,$b)=func();
4	if($a&&$b){...}
5	// Гарний приклад 
6	$a = 1 + $b;
7	list($a, $b) = func();
8	if ($a && $b) {
9	    // ...
10	}
Пояснення: Пробіли розділяють семантичні елементи і підвищують здатність швидко сканувати код очима. Відсутність пробілів ускладнює читання особливо у складних виразах (впливає на швидкість розуміння та огляду коду). Консистентний стиль зменшує cognitive load при читанні коду інших розробників.
3.2.6 Рекомендація 6. Коментарі та документація (PHPDoc)
Опис: Для всіх класів, методів та складних функцій слід використовувати PHPDoc-коментарі. Вони повинні містити короткий опис, типи параметрів та типи повернених значень.
Приклад:
1	// Поганий приклад 
2	class User {
3	    public function getData($id) { /* ... */ }
4	}
5	// Гарний приклад 
6	/**
7	 * Клас користувача
8	 */
9	class User
10	{
11	    /**
12	     * Повертає дані користувача за його ID
13	     *
14	     * @param int $id Ідентифікатор користувача
15	     * @return array Дані користувача
16	     */
17	    public function getData(int $id): array
18	    {
19	        // ...
20	    }
21	}
Пояснення: Використання PHPDoc підвищує зрозумілість коду, допомагає інструментам автодоповнення в IDE та забезпечує автоматичну генерацію документації. Це дозволить підтримувати консистентний стиль коментарів у команді та полегшить розуміння логіки коду іншими розробниками.
3.2.7 Рекомендація 7. Кодування файлу та порожній рядок у кінці
Опис: Всі PHP-файли повинні зберігатися у форматі UTF-8 без BOM і завершуватися одним порожнім рядком.
Приклад:
1	// Поганий приклад 
2	<?php
3	class Example { /* ... */ }
4	(немає порожнього рядка у кінці, файл може містити BOM)
5	// Гарний приклад 
6	<?php
7	class Example
8	{
9	    // ...
10	}
11	
12	(UTF-8 без BOM, один порожній рядок у кінці)
Пояснення: Це гарантує коректне відображення символів у різних операційних системах. Уникатимуться помилки, пов’язані з BOM-символами при відправці HTTP-заголовків або при роботі із сесіями. Один порожній рядок у кінці файлу відповідає стандарту PSR-12 та забезпечує правильну роботу VCS при порівнянні змін (diff).
3.2.8 Рекомендація 8. Довжина рядка і розбиття виразів (макс ~120 символів)
Опис: Рекомендована максимальна довжина рядка — 120 символів. Для довгих викликів/виразів виконуйте логічне розбиття на кілька рядків.
Приклад:
1	// Поганий приклад 
2	$result = $service->doSomethingVeryLongName($firstArgument,
3	$secondArgument, $thirdArgument, $fourthArgument,
4	$fifthArgument);
5	// Гарний приклад 
6	$result = $service->doSomethingVeryLongName(
7	    $firstArgument,
8	    $secondArgument,
9	    $thirdArgument,
10	    $fourthArgument,
11	    $fifthArgument
12	);
Пояснення: Довгі рядки важко читати, вимушують горизонтальне скролювання в редакторах і в diff-ах. Це ускладнює огляд змін та порівняння версій. Розбиття виразів полегшує читання кожного аргумента, спрощує вставку/видалення аргументів без великих змін в diff. 120 символів — розумна межа для сучасних моніторів і код-рев’ю; деякі команди використовують 80 символів історично, але 120 — компроміс.
3.2.9 Рекомендація 9. Іменування: класи, методи, змінні, константи
Опис: 
	Класи — StudlyCaps (PascalCase): UserProfile.
	Методи та функції — camelCase: getUserData().
	Константи — UPPER_CASE з підкресленням: MAX_USERS.
	Імена змінних — осмислені, без абревіатур, короткі коли очевидно.
Приклад:
1	// Поганий приклад 
2	class userprofile{
3	    public function GET_userDATA($uid){ ... }
4	}
5	// Гарний приклад 
6	class UserProfile
7	{
8	    public function getUserData(int $userId): array
9	    {
10	        // ...
11	    }
12	}
Пояснення: Консистентні правила іменування спрощують зрозуміння ролі елемента без заглиблення в реалізацію. PascalCase для класів і camelCase для методів — стандартна та очікувана конвенція в PHP-спільноті; порушення виглядає «чужорідно» і знижує швидкість розуміння коду. Осмислені імена зменшують потребу в коментарях («self-documenting code»). Неправильні імена підвищують ризик помилок при використанні API (неправильні виклики, плутанина).
3.2.10 Рекомендація 10. Сигнатури функцій/методів: типи, порядок, форматування
Опис:  Вказуйте типи параметрів і повернення де можливо (scalar та object типи). Якщо список параметрів довгий — переносіть кожен параметр на новий рядок.
Приклад:
1	// Поганий приклад 
2	function createUser($name,$email,$age=null){ /* ... */ }
3	// Гарний приклад 
4	function createUser(string $name, string $email, ?int $age =
5	null): User
6	{
7	    // ...
8	}
9	При довгому списку:
10	public function sendNotification(
11	    User $user,
12	    string $subject,
13	    string $message,
14	    ?\DateTimeImmutable $sendAt = null
15	): void {
16	    // ...
17	}
Пояснення: Явна типізація дозволяє виявити невідповідності ще на етапі виконання (при strict_types) і допомагає статичним аналізаторам (PHPStan/Psalm) робити подальші перевірки. Типи в сигнатурі — частина контракту методу; відсутність типів знижує читаємість API і ускладнює рефакторинг. Форматування (по рядках) робить зміни в сигнатурі менш руйнівними для VCS-дифів та зручнішими для огляду.
3.2.11 Рекомендація 11. Видимість та порядок членів класу
Опис: Вказуйте public, protected, private для властивостей та методів. Дотримуйтеся сталого порядку членів класу (наприклад: константи → властивості → конструктор → публічні методи → захищені → приватні).
Приклад:
1	// Поганий приклад 
2	class A {
3	    function do() {}
4	    private $a;
5	    public $b;
6	}
7	// Гарний приклад 
8	class A
9	{
10	    public const DEFAULT_LIMIT = 10;
11	
12	    private int $a;
13	    public string $b;
14	
15	    public function __construct(string $b)
16	    {
17	        $this->b = $b;
18	    }
19	
20	    public function doSomething(): void
21	    {
22	        // ...
23	    }
24	
25	    protected function helper(): void
26	    {
27	        // ...
28	    }
29	
30	    private function internal(): void
31	    {
32	        // ...
33	    }
34	}
Пояснення: Явна видимість — частина API контракту і допомагає зрозуміти, як клас призначено використовувати. Послідовний порядок членів пришвидшує пошук потрібного методу/властивості в класі і робить клас «предсказуваним». Наявність чіткого порядку також універсально допомагає інструментам автогенерації документації.
3.2.12 Рекомендація 12. Обробка помилок: винятки замість тихого повернення false/null
Опис:  Використовуйте виключення (Exceptions) для ситуацій, коли операція не може бути виконана через помилку; не ховайте помилки поверненням false або null без пояснення.
Приклад:
1	// Поганий приклад
2	function openFile(string $path) {
3	    $f = @fopen($path, 'r');
4	    if ($f === false) {
5	        return false;
6	    }
7	    return $f;
8	}
9	// Гарний приклад 
10	function openFile(string $path)
11	{
12	    $f = fopen($path, 'r');
13	    if ($f === false) {
14	        throw new \RuntimeException(sprintf('Не
15	вдалося відкрити файл: %s', $path));
16	    }
17	    return $f;
18	}
Пояснення: Тихі помилки ускладнюють трасування проблем: виклик коду повинен або повернути очікуваний результат, або кинути виняток з поясненням, чому операція не вдалася.Виключення дозволяють піднімати помилку на рівень, де її адекватно оброблять (логування, retry, fallback) і зберігають стек викликів. Використання @ (error suppression) ховає помилки і робить дебаг практично неможливим.
3.4 Інструменти та автоматизація для підтримки якості коду
Для забезпечення високої якості коду рекомендується використовувати комбінацію стилістичного лінту, статичного аналізу та автоматизації перевірок у CI/CD.
3.4.1 PHP_CodeSniffer (phpcs)
PHP_CodeSniffer (phpcs) використовується для перевірки коду на відповідність стандарту PSR-12. Його можна встановити через Composer командою composer require --dev squizlabs/php_codesniffer. Перевірка коду виконується за допомогою команди vendor/bin/phpcs --standard=PSR12 src/.
Приклад конфігурації phpcs.xml:
1	<?xml version="1.0"?>
2	<ruleset name="MyProject">
3	    <description>Правила форматування коду для
4	MyProject</description>
5	    <rule ref="PSR12"/>
6	    <file>src</file>
7	</ruleset>
3.4.2 PHP-CS-Fixer
PHP-CS-Fixer призначений для автоматичного виправлення стилістичних порушень. Його встановлення виконується командою composer require --dev friendsofphp/php-cs-fixer, а запуск — vendor/bin/php-cs-fixer fix src/ --rules=@PSR12.
Конфігурація (.php-cs-fixer.dist.php):
1	<?php
2	$finder = PhpCsFixer\Finder::create()->in(__DIR__ . '/src');
3	return (new PhpCsFixer\Config())
4	    ->setRules(['@PSR12' => true])
5	    ->setFinder($finder);
3.4.3 Статичний аналіз коду
Для статичного аналізу коду використовуються такі інструменти, як PHPStan, Psalm, SonarQube або Codacy. Вони допомагають знаходити логічні помилки, невідповідності типів та потенційні баги. Рекомендується поєднувати статичний аналіз із стилістичним лінтом, щоб забезпечити комплексну перевірку якості коду.
3.4.4 Автоматизація перевірок стилю
Автоматизація перевірок стилю може здійснюватися як локально, так і на рівні CI/CD. На локальному рівні зручно використовувати pre-commit hook, який запускає PHP_CodeSniffer або PHP-CS-Fixer перед створенням коміту (наприклад, через Husky або composer scripts). У CI/CD-процесах, зокрема у GitHub Actions або GitLab CI, перевірка стилю може виконуватися автоматично при кожному pull request. Такий workflow забезпечує відповідність коду стандарту PSR-12, блокує злиття змін із порушеннями стилю та за потреби може автоматично виправляти дрібні помилки форматування.
 
4 ВИСНОВКИ
У ході роботи було розглянуто основні правила оформлення PHP-коду згідно стандарту PSR-12, зокрема вимоги до відступів, пробілів, дужок, іменування, типізації та структури файлів. Наведено приклади правильного та неправильного оформлення, що допомагають краще зрозуміти логіку стандарту й уникати поширених помилок у майбутніх проєктах. Також було продемонстровано використання інструментів PHP_CodeSniffer і PHP-CS-Fixer для перевірки та автоматичного виправлення стилю коду.
Для ефективного засвоєння та застосування правил оформлення рекомендується регулярно перевіряти власний код за допомогою лінтерів і форматерів, використовувати єдині конфігурації в межах команди та дотримуватись стандарту PSR-12 ще на етапі розробки. Це дозволяє підтримувати високу якість коду, уникати хаотичного стилю та спрощує командну роботу. 
5 ВИКОРИСТАНІ ДЖЕРЕЛА
1.	PSR-12: Extended Coding Style - PHP-FIG. PHP-FIG â PHP Framework Interop Group - PHP-FIG. URL: https://www.php-fig.org/psr/psr-12/ (date of access: 31.10.2025).
2.	GitHub - squizlabs/PHP_CodeSniffer: PHP_CodeSniffer tokenizes PHP files and detects violations of a defined set of coding standards. GitHub. URL: https://github.com/squizlabs/PHP_CodeSniffer (date of access: 31.10.2025).
3.	PHP: The Right Way. PHP: The Right Way. URL: https://phptherightway.com/(date of access: 31.10.2025). 

 
ДОДАТОК А
Відеозапис доповіді: https://youtu.be/YhWHsEzNhD0
Хронологічний опис відеозапису (таймкоди):
00:00 — Тема і вступне слово;
00:14 — Мета та завдання;
00:30 — Вступ;
00:56 — Початок файлу PHP;
01:32 — namespace і use — порядок і розташування;
01:59 — Відступи — чотири пробіли, не таби;
02:18 — Дужки на новому рядку;
02:37 — Пробіли навколо операторів і після ком;
02:58 — Коментарі та документація PHPDoc;
03:19 — Кодування файлу та порожній рядок у кінці;
03:48 — Довжина рядка і розбиття виразів;
03:58 — Іменування: класи, методи, змінні, константи;
04:22 — Сигнатури функцій/методів: типи, порядок,
форматування;
04:54 — Видимість та порядок членів класу;
05:18 — Обробка помилок: винятки замість тихого
повернення false/null;
05:38 — Інструменти для підтримки якості коду;
06:13 — Висновки
07:04 — Джерела

 
ДОДАТОК Б
 
Рисунок Б.1 — Заголовний слайд: назва теми, прізвище, група, викладач
 
Рисунок Б.2 — Мета та завдання
 
Рисунок Б.3 — Що таке PRS-12
 
Рисунок Б.4 — Рекоменація 1
 
Рисунок Б.5 — Рекоменація 2
 
Рисунок Б.6 — Рекоменація 3
 
Рисунок Б.7 — Рекоменація 4
 
Рисунок Б.8 — Рекоменація 5
 
Рисунок Б.9 — Рекоменація 6
 
Рисунок Б.10 — Рекоменація 7
 
Рисунок Б.11 — Рекоменація 8
 Рисунок Б.12 — Рекоменація 9
  
Рисунок Б.13 — Рекоменація 10 
Рисунок Б.14 — Рекоменація 11
  
Рисунок Б.15 — Рекоменація 12
 
Рисунок Б.16 — Інструменти для підтримки якості

 
 
Рисунок Б.17 — Висновки
 
Рисунок Б.17 — Джерела
 
ДОДАТОК В
GitHub репозиторій з файлом коду: https://github.com/NureShabaltasVitalii/ark-pzpi-23-9-shabaltas-vitalii/blob/main/Pract1/pzpi-23-9-shabaltas-vitalii-pract1/code-examples-code-conventions.php


