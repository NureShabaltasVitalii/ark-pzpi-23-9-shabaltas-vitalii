Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук

Кафедра програмної інженерії



ЗВІТ
до практичного завдання № 2 
з дисципліни «Практичне застосування методів рефакторингу коду: Replace Magic Number, Decompose Conditional та Substitute Algorithm у PHP»






 
Виконали:
ст. гр. ПЗПІ-23-9
Шабалтас Віталій

 
                 Перевірив:
                 ст. викладач катедри ПІ
                 Сокорчук Ігор Петрович 






Харків 2025

Зміст

Зміст	2
1 ІСТОРІЯ ЗМІН	3
2 ЗАВДАННЯ	4
2.1 Мета	4
2.2 Хід роботи	4
3 ОПИС ВИКОНАНОЇ РОБОТИ	5
3.1 Вступ	5
3.2 Метод Replace Magic Number	5
3.3 Метод Decompose Conditional	6
3.4 Метод Substitute Algorithm	6
4 ВИСНОВКИ	8
5 ВИКОРИСТАНІ ДЖЕРЕЛА	9
ДОДАТОК А	10
ДОДАТОК Б	11
ДОДАТОК В	20

 
1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	11.11.2025	0.1	Створено розділ «Завдання»
2	12.11.2025	0.1	Створено розділ 
«Опис виконання роботи», «Висновок», «Використані джерела» та додатки «А», «Б» і «В»


 
2 ЗАВДАННЯ
2.1 Мета
Продемонструвати практичне застосування трьох методів рефакторингу коду в PHP — Replace Magic Number, Decompose Conditional, Substitute Algorithm — показати проблеми «до», провести перетворення коду, показати «після» та описати технічні переваги проведених змін.
 2.2 Хід роботи
1)	Ознайомитися з поняттям рефакторингу коду та його роллю в підвищенні якості програмного забезпечення;
2)	Розглянути особливості застосування рефакторингу в мовах динамічної типізації, зокрема у PHP;
3)	Для кожного методу проаналізувати його призначення, основну ідею та практичну користь;
4)	Навести приклади фрагментів коду «до» і «після» рефакторингу для кожного методу, пояснити виявлену проблему та спосіб її усунення;
5)	Порівняти результати до та після внесення змін, визначити, як саме покращилася структура й зрозумілість коду;
6)	Сформульовати висновки. 
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ
Рефакторинг — це процес поліпшення структури коду без зміни його зовнішньої поведінки. У цьому звіті розглянуто три базові техніки: Replace Magic Number (замінити «магічні числа» на зрозумілі іменовані константи), Decompose Conditional (розкласти складні умовні оператори у менші методи/функції) та Substitute Algorithm (замінити складний алгоритм на більш простий/модульний або використати інший, краще підходящий алгоритм). Приклади показані на PHP, популярній мові для вебзастосунків.
3.2 Метод Replace Magic Number
Опис: Метод Replace Magic Number полягає у заміні "магічних чисел" — незрозумілих числових або символьних значень у коді — на іменовані константи чи змінні. Це робить код читабельним, зручним у зміні та унеможливлює помилки через неправильне розуміння чисел.
Проблема: У вихідному коді використовуються так звані «магічні числа» — тобто числові значення, що не мають очевидного пояснення. Це ускладнює розуміння логіки програми, оскільки читачеві важко визначити, звідки взялося те чи інше число та яку роль воно виконує. Такий підхід негативно впливає на підтримку: при зміні політики розрахунків або знижок необхідно шукати й змінювати ці значення по всьому коду, що створює ризик помилок. Метод Replace Magic Number є оптимальним рішенням, оскільки дозволяє замінити неочевидні числові значення на зрозумілі іменовані константи.
Код до рефакторингу:

<?php
declare(strict_types=1);

function calculateDiscount(float $price, int $customerType): float
{
    if ($customerType === 1) {
        return $price * 0.95; // 5% discount
    }

    if ($customerType === 2) {
        return $price * 0.90; // 10% discount
    }

    return $price;
}

Пояснення проблеми: У цьому прикладі «магічні числа» 0.95, 0.90, 1 і 2 не дають зрозуміти, що саме вони означають. Після застосування рефакторингу ці значення будуть винесені у вигляді констант з осмисленими назвами, що одразу робить код зрозумілішим та легшим у зміні. 
Код після рефакторингу:

<?php
declare(strict_types=1);

define('DISCOUNT_REGULAR', 0.95);
define('DISCOUNT_VIP', 0.90);
define('CUSTOMER_REGULAR', 1);
define('CUSTOMER_VIP', 2);

function calculateDiscount(float $price, int $customerType): float
{
    if ($customerType === CUSTOMER_REGULAR) {
        return $price * DISCOUNT_REGULAR;
    }

    if ($customerType === CUSTOMER_VIP) {
        return $price * DISCOUNT_VIP;
    }

    return $price;
}

Переваги отриманого коду: Після рефакторингу код став значно зрозумілішим і безпечнішим у підтримці. Константи пояснюють призначення кожного значення, тому навіть без коментарів видно логіку програми. У випадку зміни відсотків знижки або типів користувачів потрібно змінити значення лише в одному місці, що знижує ризик помилок і робить код гнучкішим.

3.3 Метод Decompose Conditional
Опис: Метод Decompose Conditional застосовується для спрощення складних умов у коді. Ідея полягає в тому, щоб замінити великі або заплутані логічні вирази на окремі функції або змінні з осмисленими назвами. Завдяки цьому програма стає зрозумілішою, а логіка — більш очевидною.
Проблема: Великі й складні умовні конструкції (if з кількома логічними перевірками) роблять код важким для читання й тестування. У наведеному прикладі умови перевіряють кілька факторів одночасно: роль користувача, стан ресурсу, його власника тощо. Така логіка ускладнює розуміння, що саме перевіряється і за яких умов користувач отримує доступ. Метод Decompose Conditional дозволяє розбити складну умову на менші логічні частини, винісши їх у окремі функції.
Код до рефакторингу:

function canUserAccess(array $user, array $resource): bool
{
    if ($user['is_active'] && ($user['role'] === 'admin' || $user['role'] === 'editor') && !$resource['is_locked']) {
        return true;
    }

    if ($user['is_active'] && $user['role'] === 'author' && $resource['owner_id'] === $user['id']) {
        return true;
    }

    return false;
}

Пояснення проблеми: Така логіка перевірок важко читається і практично не піддається модульному тестуванню. Після розкладання умов на окремі функції кожна з них стає зрозумілою і може бути протестована окремо. Це спрощує підтримку, оскільки кожна функція тепер відповідає за одну конкретну перевірку. 
Код після рефакторингу:

<?php
declare(strict_types=1);

function canUserAccess(array $user, array $resource): bool
{
    if (!isActive($user)) {
        return false;
    }

    if (isAdminOrEditor($user) && !isLocked($resource)) {
        return true;
    }

    if (isAuthorAndOwner($user, $resource)) {
        return true;
    }

    return false;
}

function isActive(array $user): bool
{
    return !empty($user['is_active']);
}

function isAdminOrEditor(array $user): bool
{
    return in_array($user['role'], ['admin', 'editor'], true);
}

function isLocked(array $resource): bool
{
    return !empty($resource['is_locked']);
}

function isAuthorAndOwner(array $user, array $resource): bool
{
    return $user['role'] === 'author' && ($resource['owner_id'] ?? null) === ($user['id'] ?? null);
}

Переваги отриманого коду: Після рефакторингу код став набагато структурованішим. Кожна логічна перевірка винесена у власну функцію, що робить програму модульною та зрозумілою. Тепер легко побачити загальну логіку перевірки доступу без перевантаження деталями. Така структура спрощує тестування, оскільки кожну функцію можна перевірити окремо, а також полегшує подальше розширення програми.

3.4 Метод Substitute Algorithm
Опис: Метод Substitute Algorithm використовується, коли певний фрагмент коду реалізує надто складний алгоритм, який можна замінити на простіше або більш ефективне рішення. Основна мета — спростити реалізацію без зміни кінцевого результату.
Проблема: У програмі використовувався занадто складний алгоритм пошуку спільного префіксу в масиві рядків. Код містив вкладені цикли й ручні перевірки символів, через що він виглядав громіздко, був важким для розуміння та підтримки. У цьому випадку доцільно застосувати метод Substitute Algorithm, тобто замінити існуючий алгоритм на інший, більш простий і ефективний.
Код до рефакторингу:
<?php
declare(strict_types=1);

function commonPrefix(array $strings): string
{
    if (empty($strings)) {
        return '';
    }

    $prefix = $strings[0];
    $count = count($strings);

    for ($i = 1; $i < $count; $i++) {
        $s = $strings[$i];
        $j = 0;
        $newPrefix = '';
        while ($j < strlen($prefix) && $j < strlen($s)) {
            if ($prefix[$j] === $s[$j]) {
                $newPrefix .= $prefix[$j];
            } else {
                break;
            }
            $j++;
        }
        $prefix = $newPrefix;
        if ($prefix === '') {
            break;
        }
    }

    return $prefix;
}
Пояснення проблеми: Проблема цього фрагмента полягає в надмірній складності — він має багато вкладених перевірок і ручних ітерацій, які можна спростити. Заміна алгоритму передбачає застосування більш логічного підходу — спочатку відсортувати масив, а потім знайти спільний префікс лише між першим і останнім елементом, що значно спрощує реалізацію.
Код після рефакторингу:
<?php
declare(strict_types=1);

function commonPrefix(array $strings): string
{
    if (empty($strings)) {
        return '';
    }

    sort($strings, SORT_STRING);
    $first = $strings[0];
    $last = $strings[count($strings) - 1];
    $length = min(strlen($first), strlen($last));
    $i = 0;

    while ($i < $length && $first[$i] === $last[$i]) {
        $i++;
    }

    return substr($first, 0, $i);
}
Переваги отриманого коду: Після заміни алгоритму код став набагато коротшим і зрозумілішим, а також менш схильним до помилок. Нова реалізація виконує ту саму задачу, але за допомогою простішої логіки. Завдяки цьому підвищилась ефективність, зменшилась кількість вкладених перевірок і покращилась можливість налагодження. Такий підхід є більш елегантним і відповідає принципам чистого коду.

 
4 ВИСНОВКИ
У ході виконання практичного завдання було досліджено та застосовано три основні методи рефакторингу коду — Replace Magic Number, Decompose Conditional та Substitute Algorithm. Кожен із них продемонстрував, як за допомогою незначних, але структурно важливих змін можна суттєво покращити якість програмного коду.
Під час використання методу Replace Magic Number було усунуто неочевидні числові значення, що зробило код більш зрозумілим для розробників і зменшило ризик помилок при подальшому супроводі. Метод Decompose Conditional дозволив перетворити складні умовні вирази на набір простих і логічно названих функцій, що підвищило читабельність і спростило тестування. Використання Substitute Algorithm показало, що заміна надмірно ускладнених алгоритмів на більш оптимальні підходи робить програму ефективнішою та легшою для розуміння.
У результаті виконаної роботи було підтверджено, що систематичне застосування методів рефакторингу є необхідним етапом підтримки й розвитку будь-якого програмного продукту. Це сприяє підвищенню якості коду, його стабільності, зручності тестування та подальшої модифікації, а також допомагає уникати накопичення технічного боргу. 
5 ВИКОРИСТАНІ ДЖЕРЕЛА
1	PHP: Magic Methods - Manual. PHP. URL: https://www.php.net/manual/en/language.oop5.magic.php (date of access: 11.11.2025). 
2	GitHub - squizlabs/PHP_CodeSniffer: PHP_CodeSniffer tokenizes PHP files and detects violations of a defined set of coding standards. GitHub. URL: https://github.com/squizlabs/PHP_CodeSniffer (date of access: 11.11.2025).
3	PHP: The Right Way. PHP: The Right Way. URL: https://phptherightway.com/(date of access: 11.11.2025). 

 
ДОДАТОК А
Відеозапис доповіді: https://youtu.be/mX-Bj2aMaag
Хронологічний опис відеозапису (таймкоди):
00:00 — Тема і вступне слово
00:12 — Вступ та мета
00:27 — Метод Replice Magic Number
00:37 — Код до рефакторингу методом Replice Magic Number
00:50 — Код після рефакторингу методом Replice Magic Number
01:05 — Метод Decompose Conditional
01:16 — Код до рефакторингу методом Decompose Conditional
01:25 — Код до рефакторингу методом Decompose Conditional
01:32 — Метод Substitute Algorithm 
01:50 — Код до рефакторингу методом Substitute Algorithm
02:00 — Код після рефакторингу методом Substitute Algorithm
02:14 — Висновки
02:44 — Джерела 
ДОДАТОК Б
 
Рисунок Б.1 — Заголовний слайд: назва теми, прізвище, група, викладач
 
Рисунок Б.2 — Вступ
 
Рисунок Б.3 — Replace Magic Number
 
Рисунок Б.4 — Replace Magic Number (код до рефакторингу)
 
Рисунок Б.5 — Replace Magic Number (код після рефакторингу)
 
Рисунок Б.6 — Decompose Conditional
 
Рисунок Б.7 — Decompose Conditional (код до рефакторингу)
 
Рисунок Б.8 — Decompose Conditional (код після рефакторингу)
 
Рисунок Б.9 — Substitute Algorithm
 
Рисунок Б.10 — Substitute Algorithm (код до рефакторингу)
  
Рисунок Б.11 — Substitute Algorithm (код після рефакторингу)
  Рисунок Б.12 — Висновки
 
Рисунок Б.13 — Джерела
 
 
ДОДАТОК В
GitHub репозиторій з файлом коду: https://github.com/NureShabaltasVitalii/ark-pzpi-23-9-shabaltas vitalii/blob/8fbf1f42e9530d4dd1a54791d49fc6fada26bec5/Pract2/pzpi-23-9-shabaltas-vitalii-pract2/code-examples-refactoring-methods.php



